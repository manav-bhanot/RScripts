# Manav Bhanot

#Excercise 1

# Store the cities
cities = c('A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T')

# Get the contract matrix
contractMatrix = matrix(
 c(30,20,15,0,0,21,14,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,0,20,0,0,41,0,15,0,7,0,0,0,9,0,0,0,0,0,10,0,0,0,0,10,0,25,5,10,0,10,0,10,0,0,10,10,0,0,0,0,80,0,0,0,0,0,0,0,0,0,0,0,20,0,0,0,0,20,0,0,0,0,0,10,0,0,15,0,10,0,0,0,10,10,10,0,15,0,10,10,0,0,15,0,0,7,8,0,0,0,0,9,6,20,0,15,0,3,6,9,0,15,0,11,7,0,10,0,12,0,0,14,0,0,0,0,13,7,5,6,8,4,5,5,5,5,8,4,10,5,5,4,4,2,2,3,3,3,3,2,2,4,4,5,5,10,4,8,5,5,5,5,4,8,6,5,7,10,10,10,10,0,0,0,0,10,0,15,0,0,15,0,0,0,0,0,20,0,0,0,0,0,0,0,0,0,0,0,0,0,14,21,0,0,15,20,30,0,0,20,0,8,0,0,15,0,0,41,0,9,0,0,0,0,7,0,0,6,6,6,6,6,6,6,6,8,6,0,6,0,6,0,6,4,6,4,6,5,7,8,6,5,4,5,5,8,5,8,0,10,4,0,2,2,2,3,0,0,0,0,0,10,10,10,10,0,15,0,10,0,0,15,0,20,0,0,0),
  nrow=15,
  ncol=20,
  byrow=TRUE
)

# Take the daily requirement for each city
dailyDemand = c(6.04, 7.15, 9.04, 10.12, 5.80, 5.40, 6.20, 6.06, 7.97, 6.52, 9.05, 5.37, 3.99, 6.69, 5.85, 5.88, 4.86, 5.86, 7.00, 8.30)

# Stores the daily Power Generation by each station
dailyPowerGeneration = matrix(
  c(1,13.60,0.16,1,12.00,0.16,1,5.60,0.14,9,0.76,0.02,6,0.65,0.01,6,1.12,0.02,1,5.53,0.17,3,5.53,0.17,2,7.35,0.12,8,0.78,0.02,11,1.09,0.02,8,0.78,0.02,18,1.45,0.02,6,7.74,0.02,4,0.95,0.01),
  nrow=15,
  ncol=3,
  byrow=TRUE
)

daily_power = function() {
    
    # A boolean flag to declare if a random day is a blackout day
    isBlackoutDay = FALSE
    
    # Stores the total power generated by the power station on this random day
    totalPowerGeneratedOnThisDay = 0
    
    # Vector of size 15 to store the power generated by each station on a random day
    powerGeneratedByStation = vector(mode="numeric", length = 15)
    
    # Vector of size 20 to store the power supplied to a city i by the stations with which it has contracts
    powerSuppliedToCity = vector(mode = "numeric", length = length(cities))
    
    #Vector of size 20 to store the demand - supply for a city i
    diffInDemandAndSupplyForCity = vector(mode = "numeric", length = length(cities))
    
    # For each station, get the count of working generators on this day by sampling through an indicator variable
    for (i in 1:nrow(dailyPowerGeneration)) {
    
        # Get the number of working generators at station i on this day using the probability distribution as 
        # given in the assignment
        X = sample(0:1, dailyPowerGeneration[i,1], TRUE, c(dailyPowerGeneration[i,3],1-dailyPowerGeneration[i,3]))
        # X = sample(0:1, dailyPowerGeneration[i,1], TRUE, c(0,1))
        # print(X)
        
        # Calculate the total power generated by station i.
        # Only the working generators account for the total power generation
        # summing the X vector gives the total number of working generators at station i
        powerGeneratedByThisStation = dailyPowerGeneration[i,2] * sum(X)
        
        # stores the total power generated by station i in the vector 'powerGeneratedByStation'
        powerGeneratedByStation[i] = powerGeneratedByThisStation
        
        # Adds the total power generated by station i to the total power generated till now
        totalPowerGeneratedOnThisDay = totalPowerGeneratedOnThisDay + powerGeneratedByStation[i]
        
        # Get the power supplied to each of the city on this random day
        for (j in 1:length(cities)) {
            powerSuppliedToCity[j] = powerSuppliedToCity[j] + (contractMatrix[i,j] / 100) * powerGeneratedByThisStation
        }
    }
    
    # Get the difference between the power suppied and the demand
    for (city in 1:length(cities)) {
        diffInDemandAndSupplyForCity[city] = powerSuppliedToCity[city] - dailyDemand[city]
        if (!isBlackoutDay && diffInDemandAndSupplyForCity[city] < 0) {
            isBlackoutDay = TRUE
        }
    }
    
    # cat(powerGeneratedByStation,"\n")
    # cat("Power generated by station 14 : ",powerGeneratedByStation[14],"\n")
    
    cat("Total cities : \n",cities,"\n")
    cat("Daily Demand of the cities : \n",dailyDemand,"\n")
    cat("Amount of power suplied to each city : \n",powerSuppliedToCity,"\n")
    cat("Difference in demand and supply : \n",diffInDemandAndSupplyForCity,"\n")
    
    # cat("Total Power Generated = ",totalPowerGeneratedOnThisDay,"\n")
    # cat("Power Supplied to the County = ",sum(powerSuppliedToCity),"\n")
    # cat("Power Left to be supplied = ",totalPowerGeneratedOnThisDay - sum(powerSuppliedToCity));
    
    return (isBlackoutDay)
}

# Excercise 2

# APC defines a day to be a failure if atleast one city encounters a blackout on that day
# Returns 1 if its a blackout day, 0 otherwise
failure <- function() {
    if (daily_power()) {
        return (1)
    } else {
        return (0)
    }
}

# n: number of samples, delta: the degree of confidence sought (e.g. delta = 0.95), sample: function used to generate a single sample
imc = function(n, delta, sample) {
    sum = 0
    sumsq = 0
    
    for(i in 1:n)
    {
        x = sample()
        # print(x)
        sum = sum + x
        sumsq = sumsq + x*x
    }
    
    lambda = sum/n
    sigmasq = (sumsq + (lambda*lambda*n))/(n-1)
    se = sqrt(sigmasq/n)
    re = se/lambda
    
    qdelta = qnorm((1+delta)/2)
    ci_left = lambda-qdelta*se
    ci_right = lambda+qdelta*se
    
    # cat("Number of samples:",n,"\n")
    cat("Probability of Failure : ",lambda,"\n")
    cat("Sample variance : ",sigmasq,"\n")
    cat("Standard error : ",se,"\n")
    # cat("Relative error:",re,"\n")
    cat(delta,"-confidence interval: [",ci_left,",",ci_right,"]\n",sep="")
    
    return(lambda)
}


# Excercise 3
failure2 <- function(stationNo, probOfFailure) {
    if (daily_power2(stationNo, probOfFailure)) {
        return (1)
    } else {
        return (0)
    }
}

daily_power2 = function(s, p) {
    
    # A boolean flag to declare if a random day is a blackout day
    isBlackoutDay = FALSE
    
    # Stores the total power generated by the power station on this random day
    totalPowerGeneratedOnThisDay = 0
    
    # Vector of size 15 to store the power generated by each station on a random day
    powerGeneratedByStation = vector(mode="numeric", length = 15)
    
    # Vector of size 20 to store the power supplied to a city i by the stations with which it has contracts
    powerSuppliedToCity = vector(mode = "numeric", length = length(cities))
    
    #Vector of size 20 to store the demand - supply for a city i
    diffInDemandAndSupplyForCity = vector(mode = "numeric", length = length(cities))
    
    # For each station, get the count of working generators on this day by sampling through an indicator variable
    for (i in 1:nrow(dailyPowerGeneration)) {
        
        # Get the number of working generators at station i on this day using the probability distribution as 
        # given in the assignment
        if (i == s) {
            X = sample(0:1, dailyPowerGeneration[i,1], TRUE, c(p,1-p))
        } else {
            X = sample(0:1, dailyPowerGeneration[i,1], TRUE, c(dailyPowerGeneration[i,3],1-dailyPowerGeneration[i,3]))
        }
        # X = sample(0:1, dailyPowerGeneration[i,1], TRUE, c(0,1))
        # print(X)
        
        # Calculate the total power generated by station i.
        # Only the working generators account for the total power generation
        # summing the X vector gives the total number of working generators at station i
        powerGeneratedByThisStation = dailyPowerGeneration[i,2] * sum(X)
        
        # stores the total power generated by station i in the vector 'powerGeneratedByStation'
        powerGeneratedByStation[i] = powerGeneratedByThisStation
        
        # Adds the total power generated by station i to the total power generated till now
        totalPowerGeneratedOnThisDay = totalPowerGeneratedOnThisDay + powerGeneratedByStation[i]
        
        # Get the power supplied to each of the city on this random day
        for (j in 1:length(cities)) {
            powerSuppliedToCity[j] = powerSuppliedToCity[j] + (contractMatrix[i,j] / 100) * powerGeneratedByThisStation
        }
    }
    
    # Get the difference between the power suppied and the demand
    for (city in 1:length(cities)) {
        diffInDemandAndSupplyForCity[city] = powerSuppliedToCity[city] - dailyDemand[city]
        if (!isBlackoutDay && diffInDemandAndSupplyForCity[city] < 0) {
            isBlackoutDay = TRUE
        }
    }
    
    # cat(powerGeneratedByStation,"\n")
    # cat("Power generated by station 14 : ",powerGeneratedByStation[14],"\n")
    
    cat("Total cities : \n",cities,"\n")
    cat("Daily Demand of the cities : \n",dailyDemand,"\n")
    cat("Amount of power suplied to each city : \n",powerSuppliedToCity,"\n")
    cat("Difference in demand and supply : \n",diffInDemandAndSupplyForCity,"\n")
    
    # cat("Total Power Generated = ",totalPowerGeneratedOnThisDay,"\n")
    # cat("Power Supplied to the County = ",sum(powerSuppliedToCity),"\n")
    # cat("Power Left to be supplied = ",totalPowerGeneratedOnThisDay - sum(powerSuppliedToCity));
    
    return (isBlackoutDay)
}

# Excercise 4

# n: number of samples, delta: the degree of confidence sought (e.g. delta = 0.95), sample: function used to generate a single sample
imc2 = function(n, delta, sample, x, y) {
    sum = 0
    sumsq = 0
    
    for(i in 1:n)
    {
        x = sample(x,y)
        # print(x)
        sum = sum + x
        sumsq = sumsq + x*x
    }
    
    lambda = sum/n
    sigmasq = (sumsq + (lambda*lambda*n))/(n-1)
    se = sqrt(sigmasq/n)
    re = se/lambda
    
    qdelta = qnorm((1+delta)/2)
    ci_left = lambda-qdelta*se
    ci_right = lambda+qdelta*se
    
    # cat("Number of samples:",n,"\n")
    cat("Probability of Failure : ",lambda,"\n")
    cat("Sample variance : ",sigmasq,"\n")
    cat("Standard error : ",se,"\n")
    # cat("Relative error:",re,"\n")
    cat(delta,"-confidence interval: [",ci_left,",",ci_right,"]\n",sep="")
    
    return(lambda)
}

consortium_report <- function() {
    
    MTBF = vector(mode = "numeric", length = 15)
    
    probOfFailure = imc(100, 0.90, failure)
    meanTimeBetweenFailure = (1 / probOfFailure) - 1
    
    # For every station, reduce the probabilility by half and then calculate the mtbf
    # Store this result for each station
    for (station in 1:15) {
        p = dailyPowerGeneration[i,4]/2
        probOfFailure = imc(100, 0.90, failure2, i, p)
        MTBF[i] = (1 / probOfFailure) - 1
    }
    
    # Calculate the difference now
    stationConsideredForUpgradation = 0
    maxDiff = 0;
    for (index in 1:15) {
        if (MTBF[i] - meanTimeBetweenFailure > 4 && maxDiff < MTBF[i] - meanTimeBetweenFailure) {
            maxDiff = MTBF[i] - meanTimeBetweenFailure
            stationConsideredForUpgradation = i
        }
    }
    
}



